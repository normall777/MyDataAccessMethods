---
title: "Лабораторная работа 2"
author: "Izotov Ilya"
date: '4 октября 2018 г '
output: html_document
---
## Задачи для лабораторной: 
* манипулирование объектами данных;
* работа с циклами;
* переписывание существующего кода;
* моделирование при помощи генератора случайных величин.

## Исходные данные
Установленная среда R включает в себя набор заранее сконфигурированных массивов данных.
В данной лабораторной требуется использовать одну из них  — датафрейм из 93 машин-новинок 1993 года.
Для того, чтобы загрузить данный датафрейм, необходимо выполнить следующие команды:

```{r}
library(MASS)
data(Cars93)
```

### Задание 1
1. Выполните команду ``summary()`` на полном наборе данных. Можно ли по результату выполнения сказать сколько строк в датафрейме?
```{r}
summary(Cars93)
```
Если да, напишите сколько. Если нет, то приведите другой способ.
    
    Да, можно. Если рассмотреть первую или вторую колонку (Manufacturer или Model), там представлено количество автомобилей каждой фирмы и модели. Если сложить числа в этих колонках, то в сумме получится 93.
    Альтернативный способ - посчитать длину первого столбца командой length(Cars93$Manufacturer).
    
2. Найдите среднюю цену машин с задним приводом.
```{r}
mean(Cars93$Price[Cars93$DriveTrain=="Rear"])
```


3. Найдите минимальное число лошадиных сил автомобиля для 7 пассажиров. Для 6 пассажиров.
```{r}
min(Cars93$Horsepower[Cars93$Passengers==7])
min(Cars93$Horsepower[Cars93$Passengers==6])

```

4. Найдите машины с максимальным, минимальным и средним(медианой) расстоянием, которое машина может проехать по трассе.
Вам понадобятся 2 колонки, чтобы рассчитать расстояние. Какие?
```{r}
Cars93$distance.by.highway <- Cars93$MPG.highway*Cars93$Fuel.tank.capacity
# Машина с максимальным расстоянием
Cars93[Cars93$distance.by.highway == max(Cars93$distance.by.highway),1:2]
# Машина с минимальным расстоянием
Cars93[Cars93$distance.by.highway == min(Cars93$distance.by.highway),1:2]
# Машина с медианным расстоянием
Cars93[Cars93$distance.by.highway == median(Cars93$distance.by.highway),1:2]
```
    
    Для расчета расстояния понадобились 2 колонки: расход топлива MPG.highway и объем бака Fuel.tank.capacity. Для удобства выбора нужных автомобилей в таблицу с данными добавлен соответствующий столбец произведения двух перечисленных выше столбцов.
    
## Задание 2
В самом начале занятий приводился пример с фабрикой и производством автомобилей.
Ниже приведён пример кода, который старается оптимизировать выпуск продукции ориентируясь на доступные ресурсы.
```{r}
factory.run <- function (o.cars=1, o.trucks=1) {
  factory <- matrix(c(40,1,60,3),nrow=2, dimnames=list(c("трудодни","сталь"),c("автомобили","грузовики")))
  warehouse <- c(1600,70) #Доступно материалов на складе
  names(warehouse) <- rownames(factory) # Ресурсы (трудодни, сталь)
  reserve <- c(8,1) # Резерв (трудодни, сталь)
  names(reserve) <- rownames(factory)
  output <- c(o.cars, o.trucks) # Необходимый выход продукции (автомобили, грузовики)
  names(output) <- colnames(factory)
  
  steps <- 0 # Счётчик числа шагов цикла
  repeat {
    steps <- steps + 1 # Итерация
    needed <- factory %*% output # Подсчитаем ресурсы, которые нам нужны для производства требуемого кол-ва машин (%*% матричное умножение)
    #message(steps)
    #print(needed)
    # Если ресурсов на складе достаточно и остаток меньше или равен резерву, то мы произвели максимум возможного.
    # Нужно прекращать
    if (all(needed <= warehouse) && all((warehouse - needed) <= reserve)) {
      break()
    }
    # Если заявка слишком большая и ресурсов недостаточно, уменьшим её на 10%
    if (all(needed > warehouse)) {
      output <- output * 0.9
      next()
    }
    # Если всё наоброт, то увеличим на 10%
    if (all(needed < warehouse)) {
      output <- output * 1.1
      next()
    }
    # Если мы потребили одного ресурса слишком много, а другого недостаточно,
    # то увеличим план на случайную величину
    output <- output * (1+runif(length(output),min=-0.1,max=0.1))
  }
  result <- list(out=output, iterations=steps, need=needed) 
  return(result)
}
```

1. Выполните код и запустите эту функцию ``factory.run()``.
```{r}
a <- factory.run()
```

2. С каким входными значениями функция вызвана? Какой получился результат?

  Функция вызвана с параметрами по-умолчанию: o.cars=1 и o.trucks=1. Функция выводила слишком много промежуточных данных, которые помогают при отладке, но мешают при выполнении функции, вываливая на пользователя все расчеты. Для экономии места функция была немного доработана для вывода соответствующих интересующих результатов. Результат работы: выяснено за `r a$iterations` шагов, что можно изготовить `r a$out[1]` автомобилей и `r a$out[2]` грузовиков, потратив при этом `r a$need[1]` трудодня и `r a$need[2]` единиц стали.   
    
3. Повторите вызов 4 раза. Полученные ответы отличаются от полученных ранее? Если да, почему? Если нет, почему?

```{r}
stat <- c(factory.run(), factory.run(), factory.run(), factory.run())
mean.avto <- mean(stat[]$out[1])
mean.lorry <- mean(stat[]$out[2])
mean.workdays <- mean(stat[]$need[1])
mean.steel <- mean(stat[]$need[2])
```

Ответы меняются при каждом выполнении функции. Это связано с тем, что если один ресурс потреблен в большом количестве, а второй - в меньшем, то план меняется на случайную величину. Каждый раз случайная величина разная, поэтому, результат отличается. В среднем за 4 выполнения оказалось, что можно изготовить `r mean.avto` автомобилей и `r mean.lorry` грузовиков, потратив при этом `r mean.workdays` трудодней и `r mean.steel` единиц стали.
    
4. В приведённом коде, переменные _steps_ и _output_ находятся внутри алгоритма.
Измените функцию так, чтобы она возвращала число шагов и произведённое количество машин.

    Изменил функцию выше, она возвращает лист значений: произведенное количество машин (\$out), количество шагов (\$iterations) и неообходимое количество ресурсов (\$need)
    
5. Установите план равный тридцати автомобилям и 20 грузовикам и выполните функцию.
```{r}
a<-factory.run(30,20)
```

   5.1. Какой получили результат?
   
    Был получен следующий результат: 
```{r}
print(a$out)
```
    

   5.2. Каким получился итоговый запрос ресурсов (переменная _needed_)

    Для этого необходимо:
```{r}
print(a$need)
```
    
   
   5.3. Как много итераций пришлось пройти, чтобы получить ответ (переменная _steps_)? 
   
    Для поиска ответа понадобилось итераций:
```{r}
print(a$iterations)
```
    
   5.4. Для подсчёта можно пользоваться функциями печати (``print``, ``message``) или вернуть результат из функции.

