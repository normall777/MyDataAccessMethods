---
title: "Домашняя работа 1"
author: "Izotov Ilya"
date: "26 сентября 2018 г"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

## Работа с данными.
По адресу http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat можно получить набор данных об осадках в Канаде с 1960 по 1980 годы. Необходимо загрузить эти данные при помощи ``read.table``. Воспользуйтесь справкой, чтобы изучить аргументы, которые принимает функция. 

  * Загрузите данные в датафрейм, который назовите ``data.df``.
```{r}
data.df <- read.table("http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat")
```

- Сколько строк и столбцов в ``data.df``? Если получилось не 5070 наблюдений 27 переменных, то проверяйте аргументы.
```{r}
length(data.df[1,]); length(data.df[,1])
```

- Получите имена колонок из ``data.df``.
```{r}
names(data.df)
```
    Как видно, стандартные имена столбцов записываются как V1, V2...
    
- Найдите значение из 5 строки седьмого столбца.
```{r}
paste(data.df[5,7])
```

- Напечатайте целиком 2 строку из ``data.df``
```{r}
paste(data.df[2,])
```

- Объясните, что делает следующая строка кода ``names(data.df) <- c("year", "month", "day", seq(0,23))``. Воспользуйтесь функциями ``head`` и ``tail``, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?
```{r}
names(data.df) <- c("year", "month", "day", seq(0,23))
head(data.df)
tail(data.df)
```
    
    Первая строка дает колонкам названия. 
    1 колонка - год, 2 - месяц, 3 - день, остальные - час от 0 до 23. 
    Head показывает верхнюю часть таблицы, а tail - нижнюю. 

- Добавьте новую колонку с названием *daily*, в которую запишите сумму крайних правых 24 колонок. Постройте гистограмму по этой колонке. Какие выводы можно сделать?
```{r}
data.df.daily <- data.frame(data.df, daily=rowSums(data.df)-data.df$year-data.df$month-data.df$day)
hist(data.df.daily$daily)
```
    
    В данных имеются отрицательные значения. Эти данные необходимо обнулить, т.к. таких значений быть на практике не может.
    
- Создайте новый датафрейм ``fixed.df`` в котром исправьте замеченную ошибку. Постройте новую гистограмму, поясните почему она более корректна.
```{r}
fixed.df <- data.df
fixed.df[fixed.df < 0] <- 0
fixed.df <- data.frame(fixed.df, daily=rowSums(fixed.df)-fixed.df$year-fixed.df$month-fixed.df$day)
hist(fixed.df$daily)
```
    
    Получившаяся гистограмма более корректна, поскольку имеет только неотрицательные значения. Ошибочные отрицательные значения в данных приравнены к 0, а после этого были посчитаны новые суммарные значения
    
## Синтаксис и типизирование
* Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.

```
v <- c("4", "8", "15", "16", "23", "42")
max(v)
sort(v)
sum(v)
```
``v <- c("4", "8", "15", "16", "23", "42")`` - в переменную v помещается вектор символов (char)

``max(v)`` - поиск наибольшего символа, с которого начнется строка. В кодировке код цифры 8 стоит после цифр 0-7, поэтому максимальным элементом вектора будет выбран символ "8"

``sort(v)`` - сортировка элементов вектора по возрастанию. Символ "8" будет последним, поскольку он максимальный. "15" - будет первым, "16" - вторым, так как оба элемента начинаются на одинаковый символ, то будет сравнение по второму символу. И так дальше.

``sum(v)`` - выполнено не будет, так как тип вектора символьный, а не числовой.

* Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна.

```
#Набор команд 1
v2 <- c("5",7,12)
v2[2] + v2[3]

#Набор команд 2
df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]

#Набор команд 3
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
l4[2] + l4[4]
```

Набор команд 1 - вторая команда не будет выполнена, поскольку при инициализации переменной v2 в нее был передан элемент типа char. Вектор может хранить в себе элементы только одного типа, поэтому остальные элементы вектора тоже стали типа char. Суммировать элементы типа char оператором + не получится.

Набор команд 2 - создает датафрейм размером 1х3. Датафрейм может иметь в своем составе разные типы элементов, поэтому в данном случае будет успешно выполнено сложение двух чисел.

Набор команд 3 - создает список элементов. Элементы так же могут быть разных типов. Первое сложение успешно выполняется, поскольку указывается конкретный порядковый номер элемента списка. Следующая команда выполнена не будет, поскольку неправильное обращение к элементу. Правильным вариантом будет ``l4$z2[1]+l4$z4[1]``.

## Работа с функциями и операторами
* Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции ``seq()``, которую вы использовали раньше. Изучите эту функцию, вызвав команду ``?seq``. Испольуя полученные знания выведите на экран:
  1. Числа от 1 до 10000 с инкрементом 372. 
    
```{r}
seq(from = 1, to = 10000, by=372)
```
    
  2. Числа от 1 до 10000 длиной 50.
```{r}
seq(from=1, to=10000, length.out = 50)
```
  
* Функция ``rep()`` повторяет переданный вектор указанное число раз. Объясните разницу между ``rep(1:5,times=3)`` и ``rep(1:5, each=3)``.

```{r}
rep(1:5, times=3)
```

Данный вектор будет повторяться в том порядке, в котором передан был изначально. В times указано количество повторений.

```{r}
rep(1:5, each=3)
```

В данном случае каждый элемент вектора будет повторен сразу друг за другом в количестве раз, указанном в each.